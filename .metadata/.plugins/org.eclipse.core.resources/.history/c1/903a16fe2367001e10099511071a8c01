
#include <stdint.h>

// where is the led connected ?
// Port:	A
// Pin:	5

// All registers have to be typecasted to a volatile int pointer
// and the dereference it

//block diagram in datasheet
// memory map in reference manual
#define PERIPH_BASE				(0x40000000UL)
#define IOPORTPERIPH_OFFSET		(0x10000000UL)
#define IOPORTPERIPH_BASE		(PERIPH_BASE + IOPORTPERIPH_OFFSET)
#define GPIOA_OFFSET			(0x0000UL)
#define GPIOA_BASE				(IOPORTPERIPH_BASE + GPIOA_OFFSET)

// The RCC module which is in charge of enabling each bus to transport a clock
// RCC stands for Reset and Clock control
//
#define AHBPERIPH_OFFSET 	(0x00020000UL)
#define AHBPERIPH_BASE 		(PERIPH_BASE + AHBPERIPH_OFFSET)
#define RCC_OFFSET			(0x00001000UL)
#define RCC_BASE			(AHBPERIPH_BASE + RCC_OFFSET)

// The above peripherals contains registers that we need to access
//Next we will locate the addresses of registers we need within these peripherals
// reference manuals tells us about the registers

// Next locate registers of addresses we need within the above peripherals
// Ref man tells us about all the registers
// and the meaning of each and every bit in the registers
#define IOPEN_R_OFFSET		(0x34)
#define RCC_IOPEN_R		(*(volatile unsigned int *)(RCC_BASE + IOPEN_R_OFFSET))

// enable GPIO port A
// 1U<<0 shift 1 to position 0
#define GPIOAEN			(1U<<0) // 0b 0000 0000 0000 0000 0000 0000 0000 0001

// Micro-controllers GPIO ports have at least two registers
// DIRECTION and DATA register: Data reg is used to set pin to either input or output
// DATA register is used to store the data
// Direction register is called different names depending
//on the manufacture of the microcontroller
// in Stm32 it is called mode
// Hence we will use the mode register to configure our GPIO Pin as an output pin
// and use the data register to the data we want to write to a particular pin

/**
 * Search moder in reference manual
 * Found under GPIO registers
 * GPIOA is port A, GPIOA5 PortA pin 5
 * mode0 - mode15 refers to pin in the GPIO port
 */

#define MODE_R_OFFSET		(0x00UL)
#define GPIOA_MODE_R		(*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))


/*from GPIOx_MODER
 * setting port PA5 as
 * 01: General purpose output mode
 * (1U<<10) // set bit 10 to 1
 * &=~(1U<<11) // set only bit 11 to zero
 * invert bit 11 and perform an and with current contents of the register
 */


// after configuring pin as output mode we need to write on/off to a particular register
// to turn the led on/off called output register
/*
 * GPIOx_ODR
 * ODR - output register
 * GPIOx_IDR - Input Data Register
 * we are interested in pin 5 of GPIOx_ODR ODS(Pin 5)
 */

#define OD_R_OFFSET		(0x14UL)
#define GPIOA_OD_R		(*(volatile unsigned int *)(GPIOA_BASE + OD_R_OFFSET))

#define PIN5			(1U<<5)	// set 1 at pin5
#define LED_PIN			PIN5

#define __IO volatile
//typedef unsigned int uint32_t;

/**
 * Creating a structure to hold all the gpio registers
 * __IO is the same as volatile keyword, it is recommended
 * In the 0_led_toggle_addr program we use only the MODER and ODR registers
 */
typedef struct {
	__IO uint32_t	MODER;	/*!< GPIO port mode register, 				Address offset:  0x00*/
	__IO uint32_t	OTYPER; /*!< GPIO port output type register, 		Address offset:  0x04*/
	__IO uint32_t	OSPEEDR; /*!< GPIO port output speed register, 		Address offset:  0x08*/
	__IO uint32_t	PUPDR; /*!< GPIO port pull-up/pull-down register, 	Address offset:  0x0C*/
	__IO uint32_t	IDR; /*!< GPIO port input data register, 			Address offset:  0x10*/
	__IO uint32_t	ODR; /*!< GPIO port output data register, 			Address offset:  0x14*/
	__IO uint32_t	BSRR; /*!< GPIO port bit set/reset register, 		Address offset:  0x18*/
	__IO uint32_t	LCKR; /*!< GPIO port configuration lock register, 	Address offset:  0x1C*/
	__IO uint32_t	AFR[2]; /*!< GPIO port alternate function register, Address offset:  0x20-0x24*/
	__IO uint32_t	BRR; /*!< GPIO port bit reset register, 			Address offset:  0x28*/
}GPIOA_TypeDef;


/**
 * Creating a structure for RCC registers
 */
typedef struct {
	__IO uint32_t	CR; /*!< RCC clock control register Address offset: 0x00 */
	__IO uint32_t	ICSCR; /*!< RCC Internal clock source calibration register Address offset: 0x04 */
	__IO uint32_t	CFGR; /*!< RCC Clock configuration clock configuration register Address offset: 0x08 */
	__IO uint32_t	PLLCFGR; /*!< RCC PLL configuration  register Address offset: 0x0C */
	uint32_t 	RESERVED; /*!< RCC Reserved register Address offset: 0x10 */
	__IO uint32_t	CRRCR; /*!< RCC clock recovery RC  register Address offset: 0x14 */
	__IO uint32_t	CIER; /*!< RCC Clock interrupt enable  register Address offset: 0x18 */
	__IO uint32_t	CIFR; /*!< RCC Clock interrupt flag register Address offset: 0x1C */
	__IO uint32_t	CICR; /*!< RCC Clock interrupt clear  register Address offset: 0x20 */
	__IO uint32_t	IOPRSTR; /*!< RCC I/O port reset register Address offset: 0x24 */
	__IO uint32_t	AHBRSTR; /*!< RCC AHB peripheral reset  register Address offset: 0x28 */
	__IO uint32_t	APBRSTR1; /*!< RCC APB peripheral reset  register1 Address offset: 0x2C */
	__IO uint32_t	APBRSTR2; /*!< RCC APB peripheral reset register 2 Address offset: 0x30 */
	__IO uint32_t	IOPENR; /*!< RCC  I/O port clock enable register Address offset: 0x34 */
	__IO uint32_t	AHBENR; /*!< RCC AHB peripheral clock enable register Address offset: 0x38 */
	__IO uint32_t	APBENR1; /*!< RCC APB peripheral clock enable register 1 Address offset: 0x3C */
	__IO uint32_t	APBENR2; /*!< RCC APB peripheral clock enable register 2 Address offset: 0x40 */
	__IO uint32_t	IOPSMENR; /*!< RCC I/O port in Sleep mode clock enable  register Address offset: 0x44 */
	__IO uint32_t	AHBSMENR; /*!< RCC AHB peripheral clock enable in Sleep/Stop mode  register Address offset: 0x48 */
	__IO uint32_t	APBSMENR1; /*!< RCC APB peripheral clock enable in Sleep/Stop mode register 1 Address offset: 0x4C */
	__IO uint32_t	APBSMENR2; /*!< RCC APB peripheral clock enable in Sleep/Stop mode register 2  Address offset: 0x50 */
	__IO uint32_t	CCIPR; /*!< RCC Peripherals independent clock configuration  register Address offset: 0x54 */
	__IO uint32_t	CCIPR2; /*!< RCC Peripherals independent clock configuration  register 2 Address offset: 0x58 */
	__IO uint32_t	BDCR; /*!< RCC RTC domain control register Address offset: 0x5C */
	__IO uint32_t	CSR; /*!< RCC Control/status register Address offset: 0x60 */
}RCC_TypeDef;

#define RCC 	(*(RCC_TypeDef*) RCC_BASE)

#define GPIOA (*(GPIOA_TypeDef*) GPIOA_BASE)


int main(void){
	// This section has info on the GPIOS
	//General-purpose I/Os (GPIO)

	 /** 1. Enable clock access to GPIOA **/
	//RCC_IOPEN_R |= GPIOAEN;
	RCC.IOPENR |= GPIOAEN;

	 /** 2. Set  PA5 as output pin **/
	//from GPIOx_MODER
	//GPIOA_MODE_R |= (1U<<10); // set bit 10 to 1
	//GPIOA_MODE_R &=~(1U<<11); // set bit 11 to 0
	GPIOA.MODER |= (1U<<10); // set bit 10 to 1
	GPIOA.MODER &=~(1U<<11); // set bit 11 to 0


	while(1){
		/**3. set PA5 high **/
		// from GPIOx_ODR
		//GPIOA_OD_R |= LED_PIN;
		GPIOA.ODR |= LED_PIN;

		/**4. Experiment 2: toggle PA5 */
		//GPIOA_OD_R ^= LED_PIN;
		GPIOA.ODR ^= LED_PIN;
		for(int i=0; i<100000; i++);
	}

}





